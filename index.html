<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ¶ˆæ¶ˆä¹</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='30' cy='30' r='15' fill='red'/><circle cx='70' cy='30' r='15' fill='blue'/><circle cx='50' cy='70' r='15' fill='green'/><circle cx='30' cy='70' r='15' fill='yellow'/><circle cx='70' cy='70' r='15' fill='purple'/></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#FF6B6B',
            secondary: '#4ECDC4',
            accent: '#FFD166',
            dark: '#292F36',
            light: '#F7FFF7'
          },
          fontFamily: {
            game: ['"Comic Sans MS"', '"Marker Felt"', 'Arial', 'sans-serif']
          }
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .tile-shadow {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), inset 0 -2px 4px 0 rgba(0, 0, 0, 0.05), inset 0 2px 4px 0 rgba(255, 255, 255, 0.2);
      }
      .game-title {
        text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.1);
      }
      .btn-hover {
        transition: all 0.2s ease;
      }
      .btn-hover:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .tile-selected {
        animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
      @keyframes pulse {
        0%, 100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.05);
        }
      }
      .tile-remove {
        animation: shrink 0.3s ease forwards;
      }
      @keyframes shrink {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        100% {
          transform: scale(0);
          opacity: 0;
        }
      }
      .tile-fall {
        animation: fall 0.3s ease-out forwards;
      }
      @keyframes fall {
        0% {
          transform: translateY(-100%);
          opacity: 0.5;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }
      .score-popup {
        animation: popup 1s ease-out forwards;
        position: absolute;
        z-index: 20;
        pointer-events: none;
      }
      @keyframes popup {
        0% {
          transform: translateY(0) scale(1.2);
          opacity: 1;
        }
        80% {
          opacity: 1;
          transform: translateY(-24px) scale(1.1);
        }
        100% {
          transform: translateY(-30px) scale(1);
          opacity: 0;
        }
      }
      .tile-swapping {
        position: absolute;
        z-index: 5;
      }
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen font-game text-dark">
  <header class="bg-white/80 backdrop-blur-sm shadow-md sticky top-0 z-50 transition-all duration-300">
    <div class="container mx-auto px-4 py-3 flex justify-between items-center">
      <div class="flex items-center space-x-2">
        <i class="fa fa-puzzle-piece text-primary text-2xl"></i>
        <h1 class="text-xl md:text-2xl font-bold text-primary game-title">æ¶ˆæ¶ˆä¹</h1>
      </div>
      <nav>
        <ul class="flex space-x-4">
          <li><button id="home-btn" class="btn-hover px-3 py-1 rounded-md bg-primary/10 text-primary transition-colors hover:bg-primary/20">é¦–é¡µ</button></li>
          <li><button id="levels-btn" class="btn-hover px-3 py-1 rounded-md bg-primary/10 text-primary transition-colors hover:bg-primary/20">å…³å¡</button></li>
          <li><button id="help-btn" class="btn-hover px-3 py-1 rounded-md bg-primary/10 text-primary transition-colors hover:bg-primary/20">å¸®åŠ©</button></li>
        </ul>
      </nav>
    </div>
  </header>

  <main class="container mx-auto px-4 py-8 flex-grow">
    <section id="welcome-screen" class="flex flex-col items-center justify-center py-16">
      <div class="max-w-2xl w-full bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl p-8 text-center">
        <div class="mb-8">
          <i class="fa fa-puzzle-piece text-primary text-5xl mb-4"></i>
          <h2 class="text-[clamp(2rem,5vw,3rem)] font-bold text-primary mb-2 game-title">æ¶ˆæ¶ˆä¹</h2>
          <p class="text-gray-600 mb-6">æ¶ˆé™¤ä¸‰ä¸ªæˆ–æ›´å¤šç›¸åŒçš„å…ƒç´ ï¼ŒæŒ‘æˆ˜ä½ çš„çœ¼åŠ›å’Œååº”èƒ½åŠ›ï¼</p>
        </div>
        <div class="space-y-4 mb-8">
          <button id="start-game-btn" class="btn-hover w-full py-4 px-6 bg-primary text-white rounded-xl text-xl font-bold shadow-lg transition-all">
            <i class="fa fa-play-circle mr-2"></i>å¼€å§‹æ¸¸æˆ
          </button>
          <button id="select-level-btn" class="btn-hover w-full py-4 px-6 bg-secondary text-white rounded-xl text-xl font-bold shadow-lg transition-all">
            <i class="fa fa-th-large mr-2"></i>é€‰æ‹©å…³å¡
          </button>
        </div>
        <div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-8">
          <div class="bg-light rounded-lg p-4 shadow-md">
            <i class="fa fa-star text-accent text-3xl mb-2"></i>
            <h3 class="font-bold text-lg mb-1">å¤šç§å…³å¡</h3>
            <p class="text-sm text-gray-600">ä¸€å…±æœ‰5ä¸ªæœ‰è¶£å…³å¡ç­‰ä½ æŒ‘æˆ˜</p>
          </div>
          <div class="bg-light rounded-lg p-4 shadow-md">
            <i class="fa fa-trophy text-accent text-3xl mb-2"></i>
            <h3 class="font-bold text-lg mb-1">æˆå°±ç³»ç»Ÿ</h3>
            <p class="text-sm text-gray-600">è§£é”å„ç§æˆå°±å’Œç§°å·</p>
          </div>
          <div class="bg-light rounded-lg p-4 shadow-md">
            <i class="fa fa-refresh text-accent text-3xl mb-2"></i>
            <h3 class="font-bold text-lg mb-1">æ— é™ä¹è¶£</h3>
            <p class="text-sm text-gray-600">ç®€å•æ˜“ç©ï¼Œéš¾äºç²¾é€š</p>
          </div>
        </div>
      </div>
    </section>

    <section id="levels-screen" class="hidden py-12">
      <h2 class="text-3xl font-bold text-center text-primary mb-8 game-title">é€‰æ‹©å…³å¡</h2>
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4"></div>
    </section>

    <section id="help-screen" class="hidden py-12 max-w-3xl mx-auto">
      <div class="bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl p-8">
        <h2 class="text-3xl font-bold text-center text-primary mb-6 game-title">æ¸¸æˆå¸®åŠ©</h2>
        <div class="space-y-6">
          <div class="bg-light rounded-lg p-5 shadow-md">
            <h3 class="text-xl font-bold text-secondary mb-3"><i class="fa fa-gamepad mr-2"></i>æ¸¸æˆç©æ³•</h3>
            <p>äº¤æ¢ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ï¼Œå½¢æˆä¸‰ä¸ªæˆ–æ›´å¤šç›¸åŒå…ƒç´ çš„è¿çº¿ã€‚è¿çº¿å¯ä»¥æ˜¯æ°´å¹³æˆ–å‚ç›´çš„ã€‚å½“ä½ æ¶ˆé™¤å…ƒç´ åï¼Œä¸Šæ–¹çš„å…ƒç´ ä¼šä¸‹è½ï¼Œæ–°çš„å…ƒç´ ä¼šä»é¡¶éƒ¨ç”Ÿæˆã€‚</p>
          </div>
          <div class="bg-light rounded-lg p-5 shadow-md">
            <h3 class="text-xl font-bold text-secondary mb-3"><i class="fa fa-trophy mr-2"></i>æ¸¸æˆç›®æ ‡</h3>
            <p>æ¯ä¸ªå…³å¡éƒ½æœ‰ä¸åŒçš„ç›®æ ‡ï¼Œå¦‚è¾¾åˆ°ä¸€å®šåˆ†æ•°ã€æ¶ˆé™¤ç‰¹å®šå…ƒç´ æˆ–åœ¨é™å®šæ­¥æ•°å†…å®Œæˆä»»åŠ¡ã€‚æŸ¥çœ‹æ¯ä¸ªå…³å¡å¼€å§‹æ—¶çš„è¯´æ˜äº†è§£å…·ä½“ç›®æ ‡ã€‚</p>
          </div>
          <div class="bg-light rounded-lg p-5 shadow-md">
            <h3 class="text-xl font-bold text-secondary mb-3"><i class="fa fa-star mr-2"></i>ç‰¹æ®Šå…ƒç´ </h3>
            <ul class="list-disc pl-5 space-y-2">
              <li><span class="font-bold">ç‚¸å¼¹ï¼š</span>é€šè¿‡æ¶ˆé™¤5ä¸ªç›¸åŒå…ƒç´ å½¢æˆï¼Œå¯ä»¥æ¶ˆé™¤å‘¨å›´3x3èŒƒå›´å†…çš„æ‰€æœ‰å…ƒç´ </li>
              <li><span class="font-bold">å½©è™¹ç³–ï¼š</span>é€šè¿‡äº¤å‰æ¶ˆé™¤ä¸¤ä¸ªç‰¹æ®Šå…ƒç´ å½¢æˆï¼Œå¯ä»¥æ¶ˆé™¤æ‰€æœ‰é€‰å®šç±»å‹çš„å…ƒç´ </li>
              <li><span class="font-bold">ç›´çº¿æ¶ˆé™¤ï¼š</span>é€šè¿‡æ¶ˆé™¤4ä¸ªç›¸åŒå…ƒç´ å½¢æˆï¼Œå¯ä»¥æ¶ˆé™¤ä¸€è¡Œæˆ–ä¸€åˆ—çš„æ‰€æœ‰å…ƒç´ </li>
            </ul>
          </div>
          <div class="bg-light rounded-lg p-5 shadow-md">
            <h3 class="text-xl font-bold text-secondary mb-3"><i class="fa fa-star-half-o mr-2"></i>å¾—åˆ†è§„åˆ™</h3>
            <ul class="list-disc pl-5 space-y-2">
              <li>åŸºç¡€å¾—åˆ†ï¼šæ¯ä¸ªæ™®é€šæ¶ˆé™¤å¾—10åˆ†</li>
              <li>è¿ç»­æ¶ˆé™¤ï¼šæ¯ä¸ªåç»­çš„è¿ç»­æ¶ˆé™¤ä¼šé¢å¤–å¤šåŠ 4åˆ†</li>
              <li>ç‰¹æ®Šå…ƒç´ ï¼šä½¿ç”¨5è¿æ¶ˆã€4è¿æ¶ˆã€æ¨ªçºµäº¤å‰å…ƒç´ æ¶ˆé™¤ä¼šè·å¾—æ›´é«˜åˆ†æ•°ï¼ˆæ¯ä¸ªæ¶ˆé™¤é¢å¤–å¤šåŠ 6åˆ†ï¼‰</li>
            </ul>
          </div>
        </div>
        <div class="mt-8 text-center">
          <button id="back-from-help-btn" class="btn-hover py-3 px-6 bg-primary text-white rounded-lg text-lg font-bold shadow-md transition-all">è¿”å›</button>
        </div>
      </div>
    </section>

    <section id="game-screen" class="hidden">
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div class="bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl p-6">
          <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold text-primary game-title">å…³å¡ <span id="current-level">1</span></h2>
            <button id="back-btn" class="btn-hover p-2 rounded-full bg-gray-100 text-gray-600 transition-colors hover:bg-gray-200">
              <i class="fa fa-arrow-left"></i>
            </button>
          </div>
          <div class="space-y-4 mb-6">
            <div class="bg-light rounded-lg p-4 shadow-md">
              <h3 class="font-bold text-lg mb-2">ç›®æ ‡</h3>
              <p id="level-goal" class="text-gray-700">è·å¾— <span id="target-score">1000</span> åˆ†</p>
            </div>
            <div class="grid grid-cols-2 gap-4">
              <div class="bg-light rounded-lg p-4 shadow-md">
                <h3 class="font-bold text-lg mb-1">å¾—åˆ†</h3>
                <p id="score" class="text-2xl font-bold text-primary">0</p>
              </div>
              <div class="bg-light rounded-lg p-4 shadow-md">
                <h3 class="font-bold text-lg mb-1">æ­¥æ•°</h3>
                <p id="moves-left" class="text-2xl font-bold text-secondary">20</p>
              </div>
            </div>
          </div>
          <div class="bg-light rounded-lg p-4 shadow-md mb-6">
            <h3 class="font-bold text-lg mb-2">å…³å¡å¥–åŠ±</h3>
            <div class="flex items-center">
              <div class="flex -space-x-2">
                <div class="w-10 h-10 rounded-full bg-accent flex items-center justify-center shadow-md">
                  <i class="fa fa-star text-white"></i>
                </div>
                <div class="w-10 h-10 rounded-full bg-accent/80 flex items-center justify-center shadow-md">
                  <i class="fa fa-star text-white"></i>
                </div>
                <div class="w-10 h-10 rounded-full bg-accent/60 flex items-center justify-center shadow-md">
                  <i class="fa fa-star text-white"></i>
                </div>
              </div>
              <div class="ml-4">
                <p class="text-sm text-gray-600">3æ˜Ÿè¯„åˆ†éœ€è¦è¾¾åˆ° <span id="star-1">500</span>/<span id="star-2">800</span>/<span id="star-3">1000</span> åˆ†</p>
              </div>
            </div>
          </div>
          <button id="restart-level-btn" class="btn-hover w-full py-3 px-6 bg-secondary text-white rounded-lg text-lg font-bold shadow-md transition-all">
            <i class="fa fa-refresh mr-2"></i>é‡æ–°å¼€å§‹
          </button>
        </div>
        <div class="lg:col-span-2">
          <div class="bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl p-6">
            <div class="aspect-square max-w-md mx-auto relative">
              <div id="game-board" class="grid grid-cols-6 gap-2 w-full h-full"></div>
              <!-- æ–°å¢åˆ†æ•°åŠ¨ç”»å®¹å™¨ -->
              <div id="score-popup-container" style="pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;z-index:25;"></div>
              <div id="game-start-overlay" class="absolute inset-0 bg-dark/80 rounded-xl flex flex-col items-center justify-center z-10">
                <h3 class="text-2xl font-bold text-white mb-4">å…³å¡ <span id="overlay-level">1</span></h3>
                <p class="text-white/80 mb-6 text-center px-6" id="overlay-goal">è·å¾— 1000 åˆ†</p>
                <button id="start-level-btn" class="btn-hover py-3 px-6 bg-primary text-white rounded-lg text-lg font-bold shadow-md transition-all">
                  <i class="fa fa-play mr-2"></i>å¼€å§‹
                </button>
              </div>
              <div id="game-win-overlay" class="absolute inset-0 bg-primary/90 rounded-xl flex flex-col items-center justify-center z-10 hidden">
                <div class="text-center">
                  <i class="fa fa-trophy text-accent text-5xl mb-4"></i>
                  <h3 class="text-2xl font-bold text-white mb-2">æ­å–œè¿‡å…³ï¼</h3>
                  <p class="text-white/80 mb-2">å¾—åˆ†: <span id="final-score">0</span></p>
                  <div class="flex justify-center mb-6">
                    <div id="stars-container" class="flex space-x-2"></div>
                  </div>
                  <div class="flex space-x-3">
                    <button id="next-level-btn" class="btn-hover py-2 px-4 bg-white text-primary rounded-lg font-bold shadow-md transition-all">ä¸‹ä¸€å…³</button>
                    <button id="restart-win-btn" class="btn-hover py-2 px-4 bg-accent text-white rounded-lg font-bold shadow-md transition-all">é‡æ–°å¼€å§‹</button>
                  </div>
                </div>
              </div>
              <div id="game-lose-overlay" class="absolute inset-0 bg-dark/80 rounded-xl flex flex-col items-center justify-center z-10 hidden">
                <div class="text-center">
                  <i class="fa fa-times-circle text-primary text-5xl mb-4"></i>
                  <h3 class="text-2xl font-bold text-white mb-2">æŒ‘æˆ˜å¤±è´¥</h3>
                  <p class="text-white/80 mb-6">å¾—åˆ†: <span id="final-score-lose">0</span></p>
                  <div class="flex space-x-3">
                    <button id="try-again-btn" class="btn-hover py-2 px-4 bg-primary text-white rounded-lg font-bold shadow-md transition-all">å†è¯•ä¸€æ¬¡</button>
                    <button id="select-level-lose-btn" class="btn-hover py-2 px-4 bg-white text-dark rounded-lg font-bold shadow-md transition-all">é€‰æ‹©å…³å¡</button>
                  </div>
                </div>
              </div>
              <div id="no-matches-overlay" class="absolute inset-0 bg-dark/70 rounded-xl flex items-center justify-center z-10 hidden">
                <div class="bg-white p-6 rounded-xl text-center shadow-2xl">
                  <i class="fa fa-exclamation-circle text-accent text-4xl mb-4"></i>
                  <h3 class="text-xl font-bold text-dark mb-2">æ— æ³•æ¶ˆé™¤</h3>
                  <p class="text-gray-600 mb-4">å½“å‰æ²¡æœ‰å¯æ¶ˆé™¤çš„ç»„åˆï¼Œæ¸¸æˆå°†è‡ªåŠ¨é‡æ–°ç”Ÿæˆå¸ƒå±€</p>
                  <button id="regenerate-btn" class="btn-hover py-2 px-6 bg-primary text-white rounded-lg font-bold shadow-md transition-all">é‡æ–°ç”Ÿæˆ</button>
                </div>
              </div>
              <div id="performance-warning" class="absolute inset-0 bg-dark/70 rounded-xl flex items-center justify-center z-10 hidden">
                <div class="bg-white p-6 rounded-xl text-center shadow-2xl">
                  <i class="fa fa-bolt text-accent text-4xl mb-4"></i>
                  <h3 class="text-xl font-bold text-dark mb-2">æ€§èƒ½è­¦å‘Š</h3>
                  <p class="text-gray-600 mb-4">æ£€æµ‹åˆ°æ¸¸æˆæ€§èƒ½ä¸ä½³ï¼Œå·²è‡ªåŠ¨ä¼˜åŒ–åŠ¨ç”»æ•ˆæœä»¥ä¿æŒæµç•…åº¦</p>
                  <button id="continue-btn" class="btn-hover py-2 px-6 bg-primary text-white rounded-lg font-bold shadow-md transition-all">ç»§ç»­æ¸¸æˆ</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>
  <footer class="bg-white/80 backdrop-blur-sm shadow-inner py-4 mt-8">
    <div class="container mx-auto px-4 text-center text-gray-600 text-sm">
      <p>Â© 2025 æ¶ˆæ¶ˆä¹ | Designed by å¼€å…ƒ</p>
    </div>
  </footer>
  <script>
    // Utility function for delays
    const delay = ms => new Promise(res => setTimeout(res, ms));
    const gameConfig = {
      tileTypes: ['ğŸ±', 'ğŸ¶', 'ğŸ­', 'ğŸ¦”', 'ğŸ·', 'ğŸ¦œ'],
      boardSize: 6,
      animationDuration: 300,
      levels: [
        { id: 1, targetScore: 1000, moves: 20, stars: [500, 800, 1000] },
        { id: 2, targetScore: 1500, moves: 25, stars: [800, 1200, 1500] },
        { id: 3, targetScore: 2000, moves: 30, stars: [1200, 1600, 2000] },
        { id: 4, targetScore: 2500, moves: 35, stars: [1500, 2000, 2500] },
        { id: 5, targetScore: 3000, moves: 40, stars: [2000, 2500, 3000] }
      ]
    };
    const gameState = {
      currentLevel: 1,
      score: 0,
      movesLeft: 0,
      selectedTile: null,
      board: [],
      isBusy: false,
      useAnimations: true,
      lastAnimationStartTime: 0,
      animationTimeoutHandle: null,
      performanceMetrics: {
        animationOverTimeCount: 0,
        performanceWarningThreshold: 5
      }
    };
    // DOM elements
    const screens = {
      welcome: document.getElementById('welcome-screen'),
      levels: document.getElementById('levels-screen'),
      help: document.getElementById('help-screen'),
      game: document.getElementById('game-screen')
    };
    const elements = {
      gameBoard: document.getElementById('game-board'),
      score: document.getElementById('score'),
      movesLeft: document.getElementById('moves-left'),
      currentLevel: document.getElementById('current-level'),
      targetScore: document.getElementById('target-score'),
      star1: document.getElementById('star-1'),
      star2: document.getElementById('star-2'),
      star3: document.getElementById('star-3'),
      gameStartOverlay: document.getElementById('game-start-overlay'),
      overlayLevel: document.getElementById('overlay-level'),
      overlayGoal: document.getElementById('overlay-goal'),
      gameWinOverlay: document.getElementById('game-win-overlay'),
      gameLoseOverlay: document.getElementById('game-lose-overlay'),
      finalScore: document.getElementById('final-score'),
      finalScoreLose: document.getElementById('final-score-lose'),
      starsContainer: document.getElementById('stars-container'),
      levelGoal: document.getElementById('level-goal'),
      levelsContainer: document.getElementById('levels-screen').querySelector('.grid'),
      noMatchesOverlay: document.getElementById('no-matches-overlay'),
      regenerateBtn: document.getElementById('regenerate-btn'),
      performanceWarning: document.getElementById('performance-warning'),
      continueBtn: document.getElementById('continue-btn'),
      scorePopupContainer: document.getElementById('score-popup-container')
    };
    // Event listeners
    document.getElementById('start-game-btn').addEventListener('click', startGame);
    document.getElementById('select-level-btn').addEventListener('click', showLevels);
    document.getElementById('levels-btn').addEventListener('click', showLevels);
    document.getElementById('help-btn').addEventListener('click', showHelp);
    document.getElementById('back-from-help-btn').addEventListener('click', showWelcome);
    document.getElementById('back-btn').addEventListener('click', showLevels);
    document.getElementById('restart-level-btn').addEventListener('click', restartLevel);
    document.getElementById('start-level-btn').addEventListener('click', startLevel);
    document.getElementById('next-level-btn').addEventListener('click', nextLevel);
    document.getElementById('restart-win-btn').addEventListener('click', restartLevel);
    document.getElementById('try-again-btn').addEventListener('click', restartLevel);
    document.getElementById('select-level-lose-btn').addEventListener('click', showLevels);
    document.getElementById('home-btn').addEventListener('click', showWelcome);
    elements.regenerateBtn.addEventListener('click', () => {
      elements.noMatchesOverlay.classList.add('hidden');
      regenerateBoard();
    });
    elements.continueBtn && elements.continueBtn.addEventListener('click', () => {
      elements.performanceWarning.classList.add('hidden');
      gameState.useAnimations = false;
      gameState.performanceMetrics.animationOverTimeCount = 0;
    });
    // Core Game Logic
    function initGame() {
      generateLevels();
    }
    function generateLevels() {
      elements.levelsContainer.innerHTML = '';
      gameConfig.levels.forEach(level => {
        const levelEl = document.createElement('div');
        levelEl.className = 'bg-white rounded-xl shadow-md p-4 flex flex-col items-center text-center btn-hover';
        levelEl.innerHTML = `
          <div class="w-12 h-12 rounded-full bg-primary text-white flex items-center justify-center text-xl font-bold mb-2">
            ${level.id}
          </div>
          <h3 class="font-bold">å…³å¡ ${level.id}</h3>
          <p class="text-sm text-gray-600">ç›®æ ‡: ${level.targetScore}åˆ†</p>
        `;
        levelEl.addEventListener('click', () => selectLevel(level.id));
        elements.levelsContainer.appendChild(levelEl);
      });
    }
    function showScreen(screenToShow) {
      Object.values(screens).forEach(screen => {
        screen.classList.add('hidden');
      });
      screenToShow.classList.remove('hidden');
    }
    function showWelcome() { showScreen(screens.welcome); }
    function showLevels() { showScreen(screens.levels); }
    function showHelp() { showScreen(screens.help); }
    function startGame() { selectLevel(1); }
    function selectLevel(levelId) {
      gameState.currentLevel = levelId;
      loadLevel(levelId);
      showScreen(screens.game);
    }
    function loadLevel(levelId) {
      const level = gameConfig.levels[levelId - 1];
      if (!level) return;
      gameState.score = 0;
      gameState.movesLeft = level.moves;
      gameState.selectedTile = null;
      gameState.isBusy = false;
      elements.currentLevel.textContent = levelId;
      elements.targetScore.textContent = level.targetScore;
      elements.score.textContent = '0';
      elements.movesLeft.textContent = level.moves;
      elements.star1.textContent = level.stars[0];
      elements.star2.textContent = level.stars[1];
      elements.star3.textContent = level.stars[2];
      elements.levelGoal.innerHTML = `è·å¾— <span id="target-score">${level.targetScore}</span> åˆ†`;
      elements.overlayLevel.textContent = levelId;
      elements.overlayGoal.textContent = `è·å¾— ${level.targetScore} åˆ†`;
      generateBoard();
      elements.gameStartOverlay.classList.remove('hidden');
      elements.gameWinOverlay.classList.add('hidden');
      elements.gameLoseOverlay.classList.add('hidden');
      elements.noMatchesOverlay.classList.add('hidden');
      elements.performanceWarning.classList.add('hidden');
    }
    function startLevel() {
      elements.gameStartOverlay.classList.add('hidden');
    }
    function generateBoard() {
      elements.gameBoard.innerHTML = '';
      elements.gameBoard.style.gridTemplateColumns = `repeat(${gameConfig.boardSize}, 1fr)`;
      let attempts = 0;
      let boardGenerated = false;
      while (!boardGenerated && attempts < 100) {
        gameState.board = [];
        for (let r = 0; r < gameConfig.boardSize; r++) {
          gameState.board[r] = [];
          for (let c = 0; c < gameConfig.boardSize; c++) {
            let tileType;
            do {
              tileType = gameConfig.tileTypes[Math.floor(Math.random() * gameConfig.tileTypes.length)];
            } while (
              (c >= 2 && gameState.board[r][c-1] === tileType && gameState.board[r][c-2] === tileType) ||
              (r >= 2 && gameState.board[r-1][c] === tileType && gameState.board[r-2][c] === tileType)
            );
            gameState.board[r][c] = tileType;
          }
        }
        if (hasPossibleMoves() && findMatches().length === 0) boardGenerated = true;
        attempts++;
      }
      if (!boardGenerated) {
        for (let r = 0; r < gameConfig.boardSize; r++) {
          gameState.board[r] = [];
          for (let c = 0; c < gameConfig.boardSize; c++) {
            gameState.board[r][c] = gameConfig.tileTypes[Math.floor(Math.random() * gameConfig.tileTypes.length)];
          }
        }
      }
      updateBoardUI(true);
    }
    function createTileElement(row, col, type) {
      const tile = document.createElement('div');
      tile.className = 'tile bg-white rounded-lg flex items-center justify-center text-3xl tile-shadow transition-all duration-200 cursor-pointer';
      tile.dataset.row = row;
      tile.dataset.col = col;
      tile.textContent = type;
      tile.addEventListener('click', () => handleTileClick(row, col));
      return tile;
    }
    function getTileElement(row, col) {
      return elements.gameBoard.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    }
    async function updateBoardUI(initialRender = false) {
      elements.gameBoard.innerHTML = '';
      const animationPromises = [];
      for (let row = 0; row < gameConfig.boardSize; row++) {
        for (let col = 0; col < gameConfig.boardSize; col++) {
          const type = gameState.board[row][col];
          if (type !== null) {
            const tile = createTileElement(row, col, type);
            if (initialRender && gameState.useAnimations) {
              setTimeout(() => {
                tile.classList.add('tile-fall');
                animationPromises.push(new Promise(resolve => {
                  tile.addEventListener('animationend', function handler() {
                    tile.classList.remove('tile-fall');
                    tile.removeEventListener('animationend', handler);
                    resolve();
                  }, { once: true });
                }));
              }, row * 50 + col * 20);
            }
            elements.gameBoard.appendChild(tile);
          }
        }
      }
      if (initialRender && gameState.useAnimations) await Promise.all(animationPromises);
    }
    async function handleTileClick(row, col) {
      if (gameState.isBusy) return;
      const tile = getTileElement(row, col);
      if (!gameState.selectedTile) {
        gameState.selectedTile = { row, col, element: tile };
        tile.classList.add('tile-selected');
      } else {
        const selectedRow = gameState.selectedTile.row;
        const selectedCol = gameState.selectedTile.col;
        gameState.selectedTile.element.classList.remove('tile-selected');
        if (
          (Math.abs(row - selectedRow) === 1 && col === selectedCol) ||
          (Math.abs(col - selectedCol) === 1 && row === selectedRow)
        ) {
          gameState.isBusy = true;
          const hasMatches = await swapTiles(selectedRow, selectedCol, row, col);
          gameState.selectedTile = null;
          if (hasMatches) await processGameCycle();
          gameState.isBusy = false;
        } else {
          gameState.selectedTile = { row, col, element: tile };
          tile.classList.add('tile-selected');
        }
      }
    }
    async function swapTiles(row1, col1, row2, col2) {
      const tile1 = getTileElement(row1, col1);
      const tile2 = getTileElement(row2, col2);
      const originalTile1Data = { row: tile1.dataset.row, col: tile1.dataset.col };
      const originalTile2Data = { row: tile2.dataset.row, col: tile2.dataset.col };
      const originalTile1Content = tile1.textContent;
      const originalTile2Content = tile2.textContent;
      [gameState.board[row1][col1], gameState.board[row2][col2]] =
        [gameState.board[row2][col2], gameState.board[row1][col1]];
      let hasMatchesAfterSwap = findMatches().length > 0;
      if (gameState.useAnimations) {
        const boardRect = elements.gameBoard.getBoundingClientRect();
        const tile1Rect = tile1.getBoundingClientRect();
        const tile2Rect = tile2.getBoundingClientRect();
        tile1.classList.add('tile-swapping');
        tile2.classList.add('tile-swapping');
        tile1.style.left = `${tile1Rect.left - boardRect.left}px`;
        tile1.style.top = `${tile1Rect.top - boardRect.top}px`;
        tile1.style.width = `${tile1Rect.width}px`;
        tile1.style.height = `${tile1Rect.height}px`;
        tile2.style.left = `${tile2Rect.left - boardRect.left}px`;
        tile2.style.top = `${tile2Rect.top - boardRect.top}px`;
        tile2.style.width = `${tile2Rect.width}px`;
        tile2.style.height = `${tile2Rect.height}px`;
        tile1.textContent = gameState.board[row2][col2];
        tile2.textContent = gameState.board[row1][col1];
        void tile1.offsetWidth;
        void tile2.offsetWidth;
        tile1.style.transition = `all ${gameConfig.animationDuration / 1000}s ease-in-out`;
        tile2.style.transition = `all ${gameConfig.animationDuration / 1000}s ease-in-out`;
        tile1.style.left = `${tile2Rect.left - boardRect.left}px`;
        tile1.style.top = `${tile2Rect.top - boardRect.top}px`;
        tile2.style.left = `${tile1Rect.left - boardRect.left}px`;
        tile2.style.top = `${tile1Rect.top - boardRect.top}px`;
        await delay(gameConfig.animationDuration);
        tile1.style.transition = '';
        tile2.style.transition = '';
        tile1.classList.remove('tile-swapping');
        tile2.classList.remove('tile-swapping');
        tile1.style.left = ''; tile1.style.top = '';
        tile2.style.left = ''; tile2.style.top = '';
        tile1.style.width = ''; tile1.style.height = '';
        tile2.style.width = ''; tile2.style.height = '';
        tile1.dataset.row = originalTile2Data.row;
        tile1.dataset.col = originalTile2Data.col;
        tile2.dataset.row = originalTile1Data.row;
        tile2.dataset.col = originalTile1Data.col;
        if (!hasMatchesAfterSwap) {
          [gameState.board[row1][col1], gameState.board[row2][col2]] =
            [gameState.board[row2][col2], gameState.board[row1][col1]];
          tile1.classList.add('tile-swapping');
          tile2.classList.add('tile-swapping');
          tile1.style.left = `${tile2Rect.left - boardRect.left}px`;
          tile1.style.top = `${tile2Rect.top - boardRect.top}px`;
          tile2.style.left = `${tile1Rect.left - boardRect.left}px`;
          tile2.style.top = `${tile1Rect.top - boardRect.top}px`;
          tile1.style.width = `${tile1Rect.width}px`;
          tile1.style.height = `${tile1Rect.height}px`;
          tile2.style.width = `${tile2Rect.width}px`;
          tile2.style.height = `${tile2Rect.height}px`;
          tile1.textContent = originalTile1Content;
          tile2.textContent = originalTile2Content;
          void tile1.offsetWidth;
          void tile2.offsetWidth;
          tile1.style.transition = `all ${gameConfig.animationDuration / 1000}s ease-in-out`;
          tile2.style.transition = `all ${gameConfig.animationDuration / 1000}s ease-in-out`;
          tile1.style.left = `${tile1Rect.left - boardRect.left}px`;
          tile1.style.top = `${tile1Rect.top - boardRect.top}px`;
          tile2.style.left = `${tile2Rect.left - boardRect.left}px`;
          tile2.style.top = `${tile1Rect.top - boardRect.top}px`;
          await delay(gameConfig.animationDuration);
          tile1.style.transition = '';
          tile2.style.transition = '';
          tile1.classList.remove('tile-swapping');
          tile2.classList.remove('tile-swapping');
          tile1.style.left = ''; tile1.style.top = '';
          tile2.style.left = ''; tile2.style.top = '';
          tile1.style.width = ''; tile1.style.height = '';
          tile2.style.width = ''; tile2.style.height = '';
          tile1.dataset.row = originalTile1Data.row;
          tile1.dataset.col = originalTile1Data.col;
          tile2.dataset.row = originalTile2Data.row;
          tile2.dataset.col = originalTile2Data.col;
        }
      } else {
        tile1.textContent = gameState.board[row2][col2];
        tile2.textContent = gameState.board[row1][col1];
        tile1.dataset.row = originalTile2Data.row;
        tile1.dataset.col = originalTile2Data.col;
        tile2.dataset.row = originalTile1Data.row;
        tile2.dataset.col = originalTile1Data.col;
        if (!hasMatchesAfterSwap) {
          [gameState.board[row1][col1], gameState.board[row2][col2]] =
            [gameState.board[row2][col2], gameState.board[row1][col1]];
          tile1.textContent = originalTile1Content;
          tile2.textContent = originalTile2Content;
          tile1.dataset.row = originalTile1Data.row;
          tile1.dataset.col = originalTile1Data.col;
          tile2.dataset.row = originalTile2Data.row;
          tile2.dataset.col = originalTile2Data.col;
        }
      }
      return hasMatchesAfterSwap;
    }
    // è·å–å…¨åœºæŒ‡å®šç±»å‹æ‰€æœ‰æ ¼
    function getSameTypeTiles(type) {
      const tiles = [];
      for (let r = 0; r < gameConfig.boardSize; r++) {
        for (let c = 0; c < gameConfig.boardSize; c++) {
          if (gameState.board[r][c] === type)
            tiles.push({ row: r, col: c });
        }
      }
      return tiles;
    }
    // æ–°findMatchesï¼šè¯†åˆ«3/4/5è¿ã€äº¤å‰
    function findMatches() {
      const size = gameConfig.boardSize;
      const matches = [];
      const used = Array.from({ length: size }, () => Array(size).fill(false));
      // æ¨ªå‘
      for (let r = 0; r < size; r++) {
        let c = 0;
        while (c < size) {
          let start = c, type = gameState.board[r][c];
          while (c < size && gameState.board[r][c] === type) c++;
          let len = c - start;
          if (type && len >= 3) {
            matches.push({
              type,
              kind: len === 5 ? 'bomb' : (len === 4 ? 'row' : 'normal'),
              direction: 'row',
              cells: Array.from({ length: len }, (_, i) => ({ row: r, col: start + i }))
            });
            for (let i = start; i < c; i++) used[r][i] = true;
          }
        }
      }
      // çºµå‘
      for (let c = 0; c < size; c++) {
        let r = 0;
        while (r < size) {
          let start = r, type = gameState.board[r][c];
          while (r < size && gameState.board[r][c] === type) r++;
          let len = r - start;
          if (type && len >= 3) {
            let cross = false;
            for (let i = start; i < r; i++) if (used[i][c]) cross = true;
            matches.push({
              type,
              kind: len === 5 ? 'bomb' : (len === 4 ? 'col' : 'normal'),
              direction: 'col',
              cells: Array.from({ length: len }, (_, i) => ({ row: start + i, col: c })),
              cross
            });
          }
        }
      }
      // æ£€æµ‹äº¤å‰æ¶ˆé™¤ï¼Œä¸¤ç§ç±»å‹çš„4è¿åŠä»¥ä¸Šåœ¨åŒä¸€ç‚¹äº¤å‰
      for (let i = 0; i < matches.length; i++) {
        for (let j = i + 1; j < matches.length; j++) {
          const a = matches[i], b = matches[j];
          if (!a || !b) continue;
          if (a.kind !== 'normal' && b.kind !== 'normal') {
            for (const ac of a.cells) {
              for (const bc of b.cells) {
                if (ac.row === bc.row && ac.col === bc.col && a.type !== b.type) {
                  a.kind = b.kind = 'rainbow';
                  a.crossType = [a.type, b.type];
                  b.crossType = [a.type, b.type];
                }
              }
            }
          }
        }
      }
      // åˆå¹¶äº¤å‰æ¶ˆé™¤
      const result = [];
      const seen = {};
      for (const m of matches) {
        if (m.kind === 'rainbow') {
          const key = m.crossType.sort().join(',');
          if (!seen[key]) {
            seen[key] = true;
            result.push(m);
          }
        } else {
          result.push(m);
        }
      }
      return result;
    }
    // æ–°å¢ï¼šæ˜¾ç¤ºåˆ†æ•°åŠ¨ç”»
    function showScorePopup(score, cells) {
      if (!cells || cells.length === 0) return;
      // ä¼˜å…ˆç”¨cellsä¸­é—´çš„ç‚¹
      let center;
      if (cells.length % 2 === 1) {
        center = cells[Math.floor(cells.length/2)];
      } else {
        center = cells[0];
      }
      const tile = getTileElement(center.row, center.col);
      if (!tile) return;
      const tileRect = tile.getBoundingClientRect();
      const boardRect = elements.gameBoard.getBoundingClientRect();
      // ä¿è¯å®¹å™¨æœ‰å®šä½
      const popup = document.createElement('div');
      popup.className = 'score-popup text-lg font-bold text-accent drop-shadow-lg select-none pointer-events-none';
      popup.textContent = `+${score}`;
      // è®¡ç®—ç›¸å¯¹ä½ç½®
      popup.style.left = `${tileRect.left - boardRect.left + tileRect.width/2 - 20}px`;
      popup.style.top = `${tileRect.top - boardRect.top + tileRect.height/2 - 24}px`;
      popup.style.position = 'absolute';
      popup.style.width = '40px';
      popup.style.height = '24px';
      elements.scorePopupContainer.appendChild(popup);
      setTimeout(() => {
        popup.remove();
      }, 1000); // åŠ¨ç”»æŒç»­1s
    }
    // è®¡åˆ†è§„åˆ™
    // åŸºç¡€åˆ†ï¼šæ¯ä¸ªæ™®é€šæ¶ˆé™¤10åˆ†
    // è¿ç»­æ¶ˆé™¤ï¼šæ¯æ¬¡combo(ç¬¬äºŒæ¬¡åŠä»¥ä¸Š)å¤š4åˆ†
    // ç‰¹æ®Šå…ƒç´ æ¶ˆé™¤ï¼ˆ4ã€5è¿ã€äº¤å‰ï¼‰ï¼šæ¯ä¸ªæ¶ˆé™¤å¤šåŠ 6åˆ†
    async function processMatches(matches, comboCount) {
      if (matches.length === 0) return;
      let totalPoints = 0;
      const animationPromises = [];
      let toRemove = Array.from({ length: gameConfig.boardSize }, () => Array(gameConfig.boardSize).fill(false));
      // æ–°å¢ï¼šæ¯ç»„matchå•ç‹¬åˆ†æ•°åŠ¨ç”»
      for (const match of matches) {
        let isSpecial = false;
        let matchCells = [];
        // äº¤å‰æ¶ˆé™¤ - å½©è™¹ç³–
        if (match.kind === 'rainbow') {
          isSpecial = true;
          for (const type of match.crossType) {
            for (const { row, col } of getSameTypeTiles(type)) {
              toRemove[row][col] = true;
              matchCells.push({ row, col });
            }
          }
        }
        // 5è¿æ¶ˆ - ç‚¸å¼¹
        else if (match.kind === 'bomb') {
          isSpecial = true;
          const center = match.cells[Math.floor(match.cells.length / 2)];
          for (let r = center.row - 1; r <= center.row + 1; r++) {
            for (let c = center.col - 1; c <= center.col + 1; c++) {
              if (r >= 0 && r < gameConfig.boardSize && c >= 0 && c < gameConfig.boardSize) {
                toRemove[r][c] = true;
                matchCells.push({ row: r, col: c });
              }
            }
          }
        }
        // 4è¿æ¶ˆ - è¡Œ/åˆ—å…¨æ¶ˆ
        else if (match.kind === 'row') {
          isSpecial = true;
          const r = match.cells[0].row;
          for (let c = 0; c < gameConfig.boardSize; c++) {
            toRemove[r][c] = true;
            matchCells.push({ row: r, col: c });
          }
        } else if (match.kind === 'col') {
          isSpecial = true;
          const c = match.cells[0].col;
          for (let r = 0; r < gameConfig.boardSize; r++) {
            toRemove[r][c] = true;
            matchCells.push({ row: r, col: c });
          }
        }
        // æ™®é€š3è¿æ¶ˆ
        else if (match.kind === 'normal') {
          for (const { row, col } of match.cells) {
            toRemove[row][col] = true;
            matchCells.push({ row, col });
          }
        }
        // è®¡ç®—å¾—åˆ†
        let baseScore = 0;
        if (isSpecial) {
          // ç‰¹æ®Šå…ƒç´ æ¯æ ¼åŸºç¡€åˆ†+ç‰¹æ®Šåˆ†
          baseScore = matchCells.length * (10 + 6);
        } else {
          baseScore = matchCells.length * 10;
        }
        // è¿ç»­æ¶ˆé™¤åŠ åˆ†ï¼ˆç¬¬ä¸€è½®comboä¸åŠ ï¼Œåç»­æ¯è½®+4/æ ¼ï¼‰
        let comboBonus = comboCount > 1 ? matchCells.length * 4 : 0;
        let matchScore = baseScore + comboBonus;
        totalPoints += matchScore;

        // æ–°å¢åˆ†æ•°åŠ¨ç”»
        showScorePopup(matchScore, matchCells);
      }
      // åŠ¨ç”»å’Œæ¶ˆé™¤
      for (let r = 0; r < gameConfig.boardSize; r++) {
        for (let c = 0; c < gameConfig.boardSize; c++) {
          if (toRemove[r][c]) {
            const tileElement = getTileElement(r, c);
            if (tileElement) {
              tileElement.classList.add('tile-remove');
              if (gameState.useAnimations) {
                animationPromises.push(new Promise(resolve => {
                  tileElement.addEventListener('animationend', function handler() {
                    tileElement.removeEventListener('animationend', handler);
                    resolve();
                  }, { once: true });
                }));
              }
              tileElement.textContent = '';
              tileElement.style.visibility = 'hidden';
              gameState.board[r][c] = null;
            }
          }
        }
      }
      gameState.score += totalPoints;
      elements.score.textContent = gameState.score;
      if (gameState.useAnimations) await Promise.all(animationPromises);
    }
    async function processGameCycle() {
      let matches = findMatches();
      let combos = 0;
      while (matches.length > 0) {
        combos++;
        await processMatches(matches, combos);
        dropTilesLogical();
        generateNewTilesLogical();
        await updateBoardUIWithFallAnimation();
        matches = findMatches();
      }
      if (combos > 0) {
        gameState.movesLeft--;
        elements.movesLeft.textContent = gameState.movesLeft;
      }
      if (!hasPossibleMoves()) elements.noMatchesOverlay.classList.remove('hidden');
      checkGameState();
    }
    function dropTilesLogical() {
      for (let c = 0; c < gameConfig.boardSize; c++) {
        let emptySpaces = 0;
        for (let r = gameConfig.boardSize - 1; r >= 0; r--) {
          if (gameState.board[r][c] === null) {
            emptySpaces++;
          } else if (emptySpaces > 0) {
            gameState.board[r + emptySpaces][c] = gameState.board[r][c];
            gameState.board[r][c] = null;
          }
        }
      }
    }
    function generateNewTilesLogical() {
      for (let c = 0; c < gameConfig.boardSize; c++) {
        for (let r = 0; r < gameConfig.boardSize; r++) {
          if (gameState.board[r][c] === null) {
            gameState.board[r][c] = gameConfig.tileTypes[Math.floor(Math.random() * gameConfig.tileTypes.length)];
          }
        }
      }
    }
    async function updateBoardUIWithFallAnimation() {
      elements.gameBoard.innerHTML = '';
      const animationPromises = [];
      for (let row = 0; row < gameConfig.boardSize; row++) {
        for (let col = 0; col < gameConfig.boardSize; col++) {
          const type = gameState.board[row][col];
          if (type !== null) {
            const tile = createTileElement(row, col, type);
            if (gameState.useAnimations) {
              tile.classList.add('tile-fall');
              animationPromises.push(new Promise(resolve => {
                tile.addEventListener('animationend', function handler() {
                  tile.classList.remove('tile-fall');
                  tile.removeEventListener('animationend', handler);
                  resolve();
                }, { once: true });
              }));
            }
            elements.gameBoard.appendChild(tile);
          }
        }
      }
      if (gameState.useAnimations) await Promise.all(animationPromises);
    }
    function hasPossibleMoves() {
      for (let r = 0; r < gameConfig.boardSize; r++) {
        for (let c = 0; c < gameConfig.boardSize; c++) {
          const originalType = gameState.board[r][c];
          const neighbors = [[r, c + 1], [r + 1, c]];
          for (const [nr, nc] of neighbors) {
            if (nr >= 0 && nr < gameConfig.boardSize && nc >= 0 && nc < gameConfig.boardSize) {
              const neighborType = gameState.board[nr][nc];
              gameState.board[r][c] = neighborType;
              gameState.board[nr][nc] = originalType;
              if (findMatches().length > 0) {
                gameState.board[r][c] = originalType;
                gameState.board[nr][nc] = neighborType;
                return true;
              }
              gameState.board[r][c] = originalType;
              gameState.board[nr][nc] = neighborType;
            }
          }
        }
      }
      return false;
    }
    async function regenerateBoard() {
      gameState.isBusy = true;
      elements.noMatchesOverlay.classList.add('hidden');
      const removePromises = [];
      if (gameState.useAnimations) {
        elements.gameBoard.querySelectorAll('.tile').forEach(tile => {
          tile.classList.add('tile-remove');
          removePromises.push(new Promise(resolve => {
            tile.addEventListener('animationend', function handler() {
              tile.removeEventListener('animationend', handler);
              resolve();
            }, { once: true });
          }));
        });
        await Promise.all(removePromises);
        await delay(50);
      }
      generateBoard();
      gameState.isBusy = false;
    }
    function checkGameState() {
      const level = gameConfig.levels[gameState.currentLevel - 1];
      if (gameState.score >= level.targetScore) showWinScreen();
      else if (gameState.movesLeft <= 0) showLoseScreen();
    }
    function showWinScreen() {
      elements.finalScore.textContent = gameState.score;
      const level = gameConfig.levels[gameState.currentLevel - 1];
      let stars = 0;
      if (gameState.score >= level.stars[2]) stars = 3;
      else if (gameState.score >= level.stars[1]) stars = 2;
      else if (gameState.score >= level.stars[0]) stars = 1;
      elements.starsContainer.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        const star = document.createElement('div');
        star.className = `w-10 h-10 rounded-full flex items-center justify-center text-2xl ${
          i < stars ? 'bg-accent text-white' : 'bg-gray-200 text-gray-400'
        }`;
        star.innerHTML = '<i class="fa fa-star"></i>';
        elements.starsContainer.appendChild(star);
      }
      elements.gameWinOverlay.classList.remove('hidden');
    }
    function showLoseScreen() {
      elements.finalScoreLose.textContent = gameState.score;
      elements.gameLoseOverlay.classList.remove('hidden');
    }
    function restartLevel() {
      loadLevel(gameState.currentLevel);
    }
    function nextLevel() {
      if (gameState.currentLevel < gameConfig.levels.length) {
        selectLevel(gameState.currentLevel + 1);
      } else {
        alert('æ­å–œä½ é€šå…³äº†æ‰€æœ‰å…³å¡ï¼');
        selectLevel(1);
      }
    }
    document.addEventListener('DOMContentLoaded', initGame);
  </script>
</body>
</html>